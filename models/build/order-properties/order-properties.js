// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: order-properties/order-properties.proto
/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../google/protobuf/timestamp";
export const protobufPackage = "orderproperties";
/** Side is order side. */
export var Side;
(function (Side) {
    /** SIDE_NOT_APPLICABLE - SIDE_NOT_APPLICABLE reserves the default value, to protect against unexpected settings. */
    Side[Side["SIDE_NOT_APPLICABLE"] = 0] = "SIDE_NOT_APPLICABLE";
    /** SIDE_BUY - SIDE_BUY means that the order is to buy base_denom quantity with the price. */
    Side[Side["SIDE_BUY"] = 1] = "SIDE_BUY";
    /** SIDE_SELL - SIDE_SELL means that the order is to sell base_denom quantity with the price. */
    Side[Side["SIDE_SELL"] = 2] = "SIDE_SELL";
    Side[Side["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Side || (Side = {}));
export function sideFromJSON(object) {
    switch (object) {
        case 0:
        case "SIDE_NOT_APPLICABLE":
            return Side.SIDE_NOT_APPLICABLE;
        case 1:
        case "SIDE_BUY":
            return Side.SIDE_BUY;
        case 2:
        case "SIDE_SELL":
            return Side.SIDE_SELL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Side.UNRECOGNIZED;
    }
}
export function sideToJSON(object) {
    switch (object) {
        case Side.SIDE_NOT_APPLICABLE:
            return "SIDE_NOT_APPLICABLE";
        case Side.SIDE_BUY:
            return "SIDE_BUY";
        case Side.SIDE_SELL:
            return "SIDE_SELL";
        case Side.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var TimeInForce;
(function (TimeInForce) {
    TimeInForce[TimeInForce["NOT_USED_TIME_IN_FORCE"] = 0] = "NOT_USED_TIME_IN_FORCE";
    TimeInForce[TimeInForce["DAY"] = 1] = "DAY";
    /** GOOD_TIL_CANCELED - GTC */
    TimeInForce[TimeInForce["GOOD_TIL_CANCELED"] = 2] = "GOOD_TIL_CANCELED";
    /** AT_THE_OPENING - OPG */
    TimeInForce[TimeInForce["AT_THE_OPENING"] = 3] = "AT_THE_OPENING";
    /** AT_THE_CLOSE - CLS */
    TimeInForce[TimeInForce["AT_THE_CLOSE"] = 4] = "AT_THE_CLOSE";
    /** IMMEDIATE_OR_CANCEL - IOC */
    TimeInForce[TimeInForce["IMMEDIATE_OR_CANCEL"] = 5] = "IMMEDIATE_OR_CANCEL";
    /** FILL_OR_KILL - FOK */
    TimeInForce[TimeInForce["FILL_OR_KILL"] = 6] = "FILL_OR_KILL";
    /** GOOD_TIL_TIME - GTT */
    TimeInForce[TimeInForce["GOOD_TIL_TIME"] = 7] = "GOOD_TIL_TIME";
    TimeInForce[TimeInForce["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TimeInForce || (TimeInForce = {}));
export function timeInForceFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_TIME_IN_FORCE":
            return TimeInForce.NOT_USED_TIME_IN_FORCE;
        case 1:
        case "DAY":
            return TimeInForce.DAY;
        case 2:
        case "GOOD_TIL_CANCELED":
            return TimeInForce.GOOD_TIL_CANCELED;
        case 3:
        case "AT_THE_OPENING":
            return TimeInForce.AT_THE_OPENING;
        case 4:
        case "AT_THE_CLOSE":
            return TimeInForce.AT_THE_CLOSE;
        case 5:
        case "IMMEDIATE_OR_CANCEL":
            return TimeInForce.IMMEDIATE_OR_CANCEL;
        case 6:
        case "FILL_OR_KILL":
            return TimeInForce.FILL_OR_KILL;
        case 7:
        case "GOOD_TIL_TIME":
            return TimeInForce.GOOD_TIL_TIME;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TimeInForce.UNRECOGNIZED;
    }
}
export function timeInForceToJSON(object) {
    switch (object) {
        case TimeInForce.NOT_USED_TIME_IN_FORCE:
            return "NOT_USED_TIME_IN_FORCE";
        case TimeInForce.DAY:
            return "DAY";
        case TimeInForce.GOOD_TIL_CANCELED:
            return "GOOD_TIL_CANCELED";
        case TimeInForce.AT_THE_OPENING:
            return "AT_THE_OPENING";
        case TimeInForce.AT_THE_CLOSE:
            return "AT_THE_CLOSE";
        case TimeInForce.IMMEDIATE_OR_CANCEL:
            return "IMMEDIATE_OR_CANCEL";
        case TimeInForce.FILL_OR_KILL:
            return "FILL_OR_KILL";
        case TimeInForce.GOOD_TIL_TIME:
            return "GOOD_TIL_TIME";
        case TimeInForce.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var OrderType;
(function (OrderType) {
    /** NOT_APPLICABLE_ORDER_TYPE - Changed not used to NOT_APPLICABLE_ORDER_TYPE to avoid naming conflicts with PURCHASE in the action enum */
    OrderType[OrderType["NOT_APPLICABLE_ORDER_TYPE"] = 0] = "NOT_APPLICABLE_ORDER_TYPE";
    /** ORDER_TYPE_PURCHASE - Avoid naming conflicts with PURCHASE in the action enum */
    OrderType[OrderType["ORDER_TYPE_PURCHASE"] = 1] = "ORDER_TYPE_PURCHASE";
    OrderType[OrderType["ORDER_TYPE_SELL"] = 2] = "ORDER_TYPE_SELL";
    OrderType[OrderType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderType || (OrderType = {}));
export function orderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_APPLICABLE_ORDER_TYPE":
            return OrderType.NOT_APPLICABLE_ORDER_TYPE;
        case 1:
        case "ORDER_TYPE_PURCHASE":
            return OrderType.ORDER_TYPE_PURCHASE;
        case 2:
        case "ORDER_TYPE_SELL":
            return OrderType.ORDER_TYPE_SELL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderType.UNRECOGNIZED;
    }
}
export function orderTypeToJSON(object) {
    switch (object) {
        case OrderType.NOT_APPLICABLE_ORDER_TYPE:
            return "NOT_APPLICABLE_ORDER_TYPE";
        case OrderType.ORDER_TYPE_PURCHASE:
            return "ORDER_TYPE_PURCHASE";
        case OrderType.ORDER_TYPE_SELL:
            return "ORDER_TYPE_SELL";
        case OrderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var ProcessState;
(function (ProcessState) {
    ProcessState[ProcessState["NOT_USED_PROCESS_STATE"] = 0] = "NOT_USED_PROCESS_STATE";
    ProcessState[ProcessState["PROCESS_STATE_OPEN"] = 1] = "PROCESS_STATE_OPEN";
    ProcessState[ProcessState["PROCESS_STATE_LOCKED"] = 2] = "PROCESS_STATE_LOCKED";
    ProcessState[ProcessState["PROCESS_STATE_FAILED"] = 3] = "PROCESS_STATE_FAILED";
    ProcessState[ProcessState["PROCESS_STATE_PROCESSED"] = 4] = "PROCESS_STATE_PROCESSED";
    ProcessState[ProcessState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProcessState || (ProcessState = {}));
export function processStateFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_PROCESS_STATE":
            return ProcessState.NOT_USED_PROCESS_STATE;
        case 1:
        case "PROCESS_STATE_OPEN":
            return ProcessState.PROCESS_STATE_OPEN;
        case 2:
        case "PROCESS_STATE_LOCKED":
            return ProcessState.PROCESS_STATE_LOCKED;
        case 3:
        case "PROCESS_STATE_FAILED":
            return ProcessState.PROCESS_STATE_FAILED;
        case 4:
        case "PROCESS_STATE_PROCESSED":
            return ProcessState.PROCESS_STATE_PROCESSED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProcessState.UNRECOGNIZED;
    }
}
export function processStateToJSON(object) {
    switch (object) {
        case ProcessState.NOT_USED_PROCESS_STATE:
            return "NOT_USED_PROCESS_STATE";
        case ProcessState.PROCESS_STATE_OPEN:
            return "PROCESS_STATE_OPEN";
        case ProcessState.PROCESS_STATE_LOCKED:
            return "PROCESS_STATE_LOCKED";
        case ProcessState.PROCESS_STATE_FAILED:
            return "PROCESS_STATE_FAILED";
        case ProcessState.PROCESS_STATE_PROCESSED:
            return "PROCESS_STATE_PROCESSED";
        case ProcessState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var ClearingBroker;
(function (ClearingBroker) {
    ClearingBroker[ClearingBroker["NOT_USED_CLEARING_BROKER"] = 0] = "NOT_USED_CLEARING_BROKER";
    ClearingBroker[ClearingBroker["ALPACA"] = 1] = "ALPACA";
    ClearingBroker[ClearingBroker["RQD"] = 2] = "RQD";
    ClearingBroker[ClearingBroker["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClearingBroker || (ClearingBroker = {}));
export function clearingBrokerFromJSON(object) {
    switch (object) {
        case 0:
        case "NOT_USED_CLEARING_BROKER":
            return ClearingBroker.NOT_USED_CLEARING_BROKER;
        case 1:
        case "ALPACA":
            return ClearingBroker.ALPACA;
        case 2:
        case "RQD":
            return ClearingBroker.RQD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ClearingBroker.UNRECOGNIZED;
    }
}
export function clearingBrokerToJSON(object) {
    switch (object) {
        case ClearingBroker.NOT_USED_CLEARING_BROKER:
            return "NOT_USED_CLEARING_BROKER";
        case ClearingBroker.ALPACA:
            return "ALPACA";
        case ClearingBroker.RQD:
            return "RQD";
        case ClearingBroker.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseProcessInfo() {
    return { ProcessState: 0, ProcessedAt: undefined };
}
export const ProcessInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ProcessState !== 0) {
            writer.uint32(8).int32(message.ProcessState);
        }
        if (message.ProcessedAt !== undefined) {
            Timestamp.encode(toTimestamp(message.ProcessedAt), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProcessInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.ProcessState = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ProcessedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ProcessState: isSet(object.ProcessState) ? processStateFromJSON(object.ProcessState) : 0,
            ProcessedAt: isSet(object.ProcessedAt) ? fromJsonTimestamp(object.ProcessedAt) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ProcessState !== 0) {
            obj.ProcessState = processStateToJSON(message.ProcessState);
        }
        if (message.ProcessedAt !== undefined) {
            obj.ProcessedAt = message.ProcessedAt.toISOString();
        }
        return obj;
    },
    create(base) {
        return ProcessInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseProcessInfo();
        message.ProcessState = (_a = object.ProcessState) !== null && _a !== void 0 ? _a : 0;
        message.ProcessedAt = (_b = object.ProcessedAt) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
